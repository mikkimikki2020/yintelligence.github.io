<!DOCTYPE HTML>
<html lang="en">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Instructions and Addresses for Sequential Computers, Chaoqun Yin">
    <meta name="description" content="Veni, Vidi, Vici">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Instructions and Addresses for Sequential Computers | Chaoqun Yin</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.3.0"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Chaoqun Yin</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Contact</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Chaoqun Yin</div>
        <div class="logo-desc">
            
            Veni, Vidi, Vici
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/8.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Instructions and Addresses for Sequential Computers</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Computer-Systems/">
                                <span class="chip bg-color">Computer Systems</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Computer-Systems/" class="post-category">
                                Computer Systems
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2021-07-21
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>Update Date:&nbsp;&nbsp;
                    2021-09-01
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>Word Count:&nbsp;&nbsp;
                    9.7k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>Read Times:&nbsp;&nbsp;
                    43 Min
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>Read Count:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="instructions-and-addresses-for-sequential-computers">Instructions and Addresses for Sequential Computers</h1>
<p><a href="https://yintelligence.tech/2021/01/15/2021-01-15-Computer-Systems/">VUB 4004876EER Computer Systems</a> + <a target="_blank" rel="noopener" href="https://vub.cloud.panopto.eu/Panopto/Pages/Viewer.aspx?id=ce6dd474-4f9a-49bd-b00e-ac4100eb7d20">Video</a> + <a target="_blank" rel="noopener" href="https://canvas.vub.be/courses/20575/files?preview=564887">Slide</a></p>
<h2 id="generic-instructions">1. Generic Instructions</h2>
<blockquote>
<p>在本课程的第一部分中，介绍了计算机指令的最通用格式。</p>
</blockquote>
<p>There are 2 types of instructions:</p>
<ul>
<li><strong>data processing instructions 数据处理指令</strong></li>
<li><strong>control instructions 控制指令</strong></li>
</ul>
<p><img src="/images/NET/image-20210901073955512.png" /></p>
<ul>
<li><strong>Inefficient</strong>: the address of the next instruction is stored in each instruction.</li>
</ul>
<p>In both types of instructions there are 5 separate fields, the first called "<strong><code>opcode</code></strong>" always indicates the nature of the instruction.</p>
<p>Other fields have slightly different functions depending on the type of instruction.</p>
<p>在两种类型的指令中，都有5个<u>单独的字段separate fields</u>，第一个称为“<strong><code>Opcode</code></strong>”的字段始终指示指令的性质。</p>
<p>根据指令的类型，其他字段的功能略有不同。</p>
<p>In both types of instructions, it is often possible to replace the address of an operand by its value when the latter is a constant.</p>
<p>在两种类型的指令中，当操作数为常量时，通常都可以用其值替换操作数的地址。</p>
<h3 id="data-processing-instructions-数据处理指令">1.1 Data processing instructions 数据处理指令</h3>
<p>In data processing instructions typically two operands are combined by the arithmetic logic unit to provide a result.</p>
<p>在数据处理指令中，通常两个<strong>算术数operand</strong>由<strong>算术逻辑单元arithmetic logic unit</strong>组合以提供结果。</p>
<p>These instructions will contain two fields for each of the addresses of the two operands and a field for the address where the result should be stored.</p>
<p>这些指令将为两个操作数<code>operand</code>的每个地址包含两个字段，并为应将结果存储在其中的地址包含一个字段。</p>
<p>The last field contains the address where the next instruction can be found.</p>
<p>最后一个字段包含可以找到下一条指令的地址。</p>
<h3 id="control-instructions-控制指令">1.2 Control instructions 控制指令</h3>
<p>In the control instructions one finds also the address of operands whose value must be compared.</p>
<p>The <code>result</code> of this comparison will select one of the two choices for the address of the next instruction.</p>
<p>在控制指令中，还可以找到必须比较其值的操作数的地址。</p>
<p>比较结果将为下一条指令的地址选择两个选项之一。</p>
<h2 id="von-neumann-bottleneck">2. Von Neumann Bottleneck</h2>
<p>The generic instructions in previous are probably conceptually attractive but <u>lead to weak computer</u>s.</p>
<p>上一节中的通用指令可能在概念上很有吸引力，但会<u>导致计算机性能下降</u>。</p>
<p><img src="/images/NET/image-20210901074053064.png" /></p>
<p>Indeed, if we assume that the <u>addresses</u> and <u>words</u> of memory have a 4- byte length and the operation codes of instructions a length of 2 bytes, performing a data processing instruction would require transfer of 30 bytes between memory and the CPU.</p>
<p>Under these conditions the <u><strong>connection</strong> between memory and CPU</u> would certainly be the bottleneck that limits the computer's performance.</p>
<p>事实上，如果我们假设存储器的<u>地址address</u>和<u>字长word</u>为4个字节，指令的操作码为2个字节，那么执行数据处理指令将需要在存储器和CPU之间传输30个字节。</p>
<p>在这种情况下，<strong>内存和CPU之间的连接</strong>肯定会成为限制计算机性能的<strong>瓶颈</strong>。 由于瓶颈是使用单个存储器存储数据和指令的冯·诺依曼架构的直接结果，因此通常称为“冯·诺依曼瓶颈”。</p>
<p>As the bottleneck is a direct consequence of the Von Neumann architecture that <u>uses a <strong>single memory</strong> for data and instructions</u>, it is often called "<strong>von Neumann bottleneck</strong>".</p>
<p>由于瓶颈是<u>使用<strong>单个存储器</strong>存储数据和指令</u>的冯·诺依曼架构的直接结果，因此通常称为“<strong>冯·诺依曼瓶颈von Neumann bottleneck</strong>”。</p>
<blockquote>
<p>在本课程的以下部分，将介绍限制冯·诺依曼瓶颈的不利影响的不同技术。</p>
<p>冯·诺依曼瓶颈也是选择专用计算机的哈佛体系结构Harvard architecture的一个论点。</p>
</blockquote>
<h2 id="goal-1-reduce-the-bottleneck">3. Goal 1: Reduce the bottleneck</h2>
<ul>
<li>Eliminate the <code>next</code> instruction address
<ul>
<li>By using a P register （program counter）</li>
</ul></li>
<li>Reduce size of data handling instructions
<ul>
<li>By using a <strong>stack</strong> for <u>expression evaluation</u></li>
<li>By using <strong>regiters</strong> for <u>intermediate results</u></li>
</ul></li>
<li>Reduce size of control instructions
<ul>
<li>By using <strong>ALU side effects</strong> stored in the condition codes register</li>
</ul></li>
<li>Augment work done by one instruction
<ul>
<li>By using vector instruction</li>
</ul></li>
</ul>
<h3 id="eliminate-the-next-instruction-address">3.1 Eliminate the <code>next</code> instruction address</h3>
<blockquote>
<p><strong><em>Program counter 程序计数器</em></strong></p>
<p>在处理单元设置寄存器（register），P register中存储一系列连续的地址，而I register中存储instruction，这样每一次运算，instruction format 中的next就可以省略。</p>
<p>值得注意的是，control unit中还会留有一个next指令，因为control指令的任务就是改变指令的顺序，所以需要next指令</p>
</blockquote>
<p>The first is to use a <strong>program counter</strong> instead of the <code>next</code> field in each instruction that contains the address of following instruction to be executed.</p>
<p>第一种是在每个指令中使用<strong>程序计数器program counter</strong>，而不是包含要执行的下一条指令的地址的<code>next</code>字段。</p>
<p><img src="/images/NET/image-20210901074139286.png" /></p>
<ul>
<li><p>Instead of providing in each instruction a field that contains the address of the next instruction to be executed, we <u>place the instructions at <strong>consecutive addresses</strong> in memory</u> and <u>add to the controlunit a <strong>specific register</strong></u> to store the address of the next instruction to be executed.</p>
<p>This register, which is called the program counter or the P register is incremented during execution of the instruction.</p>
<p>我们没有在每个指令中提供包含要执行的下一条指令的地址的字段，而是<u>将指令放置在内存中的<strong>连续地址consecutive addresses</strong>处</u>，并向控制单元CU添加了一个<u>特定的<strong>寄存器register</strong></u>来存储<u>要执行的下一条指令的地址</u>。</p>
<p>在执行指令期间，称为程序计数器或P寄存器的该寄存器递增。</p></li>
<li><p>Next to the register P, the control unit also contains a <strong>register I</strong> intended to <u>contain each instruction during its execution</u>.</p>
<p>在寄存器P的旁边，控制单元还包含一个<strong>寄存器I</strong>，旨在<u>在执行过程中包含每个指令</u></p></li>
</ul>
<p>The introduction of the <strong>P register</strong> in the control unit has the effect of <u>removing the field <code>next</code> from all data processing instructions.</u></p>
<p>在控制单元中引入<strong>P寄存器</strong>的作用是<u>从所有数据处理指令中删除字段<code>next</code></u>。</p>
<p><img src="/images/NET/image-20210901074238284.png" /></p>
<ul>
<li>Default <code>next</code> address is computed in P register</li>
</ul>
<p>In the control instructions, one of the two fields "next&gt; disappears, but the other remains, since the specific role of control instructions is to <u><strong>change the order of execution of instructions.</strong></u></p>
<p>在控制指令中，<code>next</code>这两个字段之一消失了，但是另一个保留了，因为控制指令的特定作用是<strong>改变指令的执行顺序</strong>。</p>
<blockquote>
<p>在使用程序计数器作为参考寄存器的跳转指令中，使用相对寻址relative addressing</p>
</blockquote>
<h3 id="reduce-size-of-data-handling-instructions">3.2 Reduce size of data handling instructions</h3>
<h4 id="stack-for-expression-evaluation">3.2.1 Stack for expression evaluation</h4>
<h5 id="stack">3.2.1.1 Stack</h5>
<p>A stack is a structure in which data are introduced and removed solely from the top, which means that the last inputted data are those that can be fetched first.</p>
<p>Some computers have their memory for data organized as a stack, with the arithmetic logic unit which takes its operands of the top two places in the stack and replaces the result at the top.</p>
<p>堆栈是一种结构，其中仅从顶部引入和删除数据，这意味着最后输入的数据是可以首先获取的数据。</p>
<p><img src="/images/NET/image-20210901074352563.png" /></p>
<blockquote>
<p>stack处理时，同时吞入stack上方的两个元素，处理完，吐出一个res放在上方，这样在instruction format里就可以只留下操作指令，其余都可以省略。</p>
<p>栈运算虽然不需要任何地址，但是操作数会远远大于普通的运算，所以有时候弊大于利。</p>
</blockquote>
<p>某些计算机的数据存储器以堆栈的形式组织，而算术逻辑单元将其操作数放在堆栈顶部的两个位置，并将结果替换在顶部。</p>
<blockquote>
<p>如果把计算机看成一个有条不紊的工厂，我们可以得到如下<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ffe303d96dbd">类比</a>。</p>
<ul>
<li>CPU是完成工作的工人。</li>
<li>数据区、堆区、栈区等则是用来存放原料、半成品、成品等各种东西的场所。</li>
<li>存在代码区的指令则告诉CPU要做什么，怎么做，到哪里去领原材料，用什么工具来做，做完以后把成品放到哪个货舱去。</li>
</ul>
<p>值得一提的是，栈除了扮演存放原料、半成品的仓库之外，它还是车间调度主任的办公室。</p>
<p>程序中所使用的缓冲区可以是堆区、栈区和存放静态变景的数据区。缓冲区溢出的利用方法和缓冲区到底属于上面哪个内存区域密不可分。</p>
</blockquote>
<p><img src="/images/NET/image-20210901074429350.png" /></p>
<p>With a stack based architecture, we must no longer provide address fields in data processing instructions as <u>operands are taken at the top of the stack and the result pushed back on the top.</u></p>
<p>使用基于堆栈的体系结构时，我们不再必须在数据处理指令中提供地址字段，</p>
<p>因为操作数位于堆栈的顶部，而结果被推回顶部。</p>
<p>In return, the <strong><u>instruction set must be augmented</u></strong> with instructions designed to <u>transfer data between any address in the memory and the top of the stack</u> in order to bring the operands at the top of the stack and place the results in the desired memory location.</p>
<p>作为回报，指令集instruction set必须<strong>增加指令instruction</strong>，这些指令旨在<u>在存储器中的任何地址和堆栈的顶部之间传输数据</u>，以便将操作数置于堆栈的顶部，并将结果放置在所需的存储器位置。</p>
<h5 id="expression-evaluation">3.2.1.2 Expression evaluation</h5>
<p>A stack is particularly useful to evaluate expressions because it provides automatic management of interim results in the evaluation of an expression with parentheses.</p>
<p>堆栈对于评估表达式特别有用，因为它在对带括号的表达式进行评估时提供了对过渡结果的自动管理。</p>
<p><img src="/images/NET/image-20210901074516045.png" /></p>
<p>First, the expression needs to be translated from the classical notation with parentheses to the <strong>Reverse Polish Notation（RPN）</strong> in which the operator is written immediately after the operands rather than between.</p>
<p>首先，需要将表达式从带括号的经典符号转换为<u><strong>Reverse Polish Notation反向波兰符号（RPN）</strong></u>，在该格式中，运算符紧接在操作数之后而不是在操作数之间。</p>
<p>The expression a + b is written ab+ in reverse Polish notation. The picture shows the transcription of an expression a bit more complex with parentheses.</p>
<p>表达式a + b以反波兰语表示为ab +。下图显示带括号的表达式的转录transcription。</p>
<p><img src="/images/NET/image-20210901074541460.png" /></p>
<h6 id="reverse-polish-notation-反向波兰符号rpn">3.2.1.2.1 Reverse Polish Notation 反向波兰符号（RPN）</h6>
<p>For the evaluation of the expression, we read the expression in Reverse Polish Notation and each encountered operand is pushed on the stack.</p>
<p>When meeting an operator, it is applied on the two operands at the top of the stack which are replaced by the result of the operation.</p>
<p>为了评估表达式，我们以反向波兰表示法读取了表达式，并将每个遇到的操作数压入堆栈。</p>
<p>当遇到一个运算符时，它将应用于堆栈顶部的两个操作数，并由运算结果替换。</p>
<blockquote>
<p>On the screen are successively shown the status of the stack after the operands a, b, c and d have been pushed on the stack, after c and d have been multiplied, after b was added to the product of c by d, and finally after the preceding result was multiplied by a.</p>
<p>在屏幕上依次显示在将操作数a，b，c和d推入堆栈之后，将c和d相乘之后，将b与d相加到c的乘积之后，最后显示堆栈的状态将前面的结果乘以a之后。</p>
</blockquote>
<p>We have seen in the previous two screens how a stack architecture simplifies the evaluation of complex expressions and makes the corresponding code shorter since it must not handle <strong>intermediate results</strong>.</p>
<p>在前面的两个屏幕中，我们已经看到了堆栈体系结构如何简化对复杂表达式的求值并缩短相应的代码，因为它<strong>不能处理中间结果</strong>。</p>
<p>Nevertheless, one can wonder whether this kind of architecture helps to avoid the effects of the von Neumann bottleneck.</p>
<p>然而，人们可能想知道这种架构是否有助于避免冯·诺依曼瓶颈的影响。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">0 addresses （stack）</th>
<th style="text-align: center;">3 addresses（traditional）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">push a</td>
<td style="text-align: center;">add a,b,c</td>
</tr>
<tr class="even">
<td style="text-align: center;">push b</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">add</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">pop</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<blockquote>
<p>Efficieny depends on type of program</p>
</blockquote>
<p>事实上，如果我们考虑与计算屏幕上显示的简单表达式simple expression相对应的代码，我们会在左侧看到:</p>
<ul>
<li><p>For a <strong>stack</strong> architecture, three transfer instructions which each contain an address and operation code and one instruction that contains only an operation code.</p>
<p>对于<strong>堆栈架构</strong>，三个传输指令，每个指令包含地址和操作代码，以及一条指令只包含一个操作码。</p></li>
<li><p>For <strong>traditional</strong> architecture with three addresses in the data processing instructions, just three addresses and one operation code are needed, in fact, three operation codes less than with a stack architecture.</p>
<p>对于数据处理指令中具有三个地址的<strong>传统体系结构</strong>，仅需要三个地址和一个操作代码，实际上，与堆栈体系结构相比，需要三个操作代码。</p></li>
</ul>
<p>One can conclude that the stack architecture becomes only interesting when the program contains many complex expressions.</p>
<p>可以得出结论，只有当程序包含许多复杂的表达式时，堆栈体系结构才会变得有趣。</p>
<p>As software engineering encourages us to write simple and easy to understand programs, very complex expressions are not widespread in modern programs and the benefits of stack architectures is negligible or even negative.</p>
<p>随着软件工程鼓励我们编写简单易懂的程序，非常复杂的表达式在现代程序中并不普遍，并且堆栈体系结构的好处可忽略不计甚至是负面的。</p>
<blockquote>
<p>栈运算虽然不需要任何地址，但是操作数会远远大于普通的运算，所以有时候弊大于利。</p>
</blockquote>
<h4 id="registers-for-intermediate-results">3.2.2 Registers for intermediate results</h4>
<blockquote>
<p>和之前的P register相似，在CPU和memory之间设置一个register，当我们操作的量1恰好也可以作为输出量时，就可以将另外一个量存储在register中，就减少一个需要传递的信息。</p>
</blockquote>
<p>Since the management of interim results using a stack does not offer great advantages and on the contrary, <u>stacks are sometimes a source of unnecessary complexity</u>, a better way to avoid having to write all intermediate results in memory has been invented.</p>
<p>由于使用堆栈管理中期结果并不能提供很大的优势，相反，如上一节所示，<u>堆栈有时会导致不必要的复杂性</u>，这是避免将所有中间结果写入内存的更好方法。</p>
<p>它包含<strong>处理器寄存器processor registers</strong>。</p>
<h5 id="registers">3.2.2.1 Registers</h5>
<p>Inside the CPU a small number (typically 8, 16 or 32) of <strong>addressable registers</strong> with fast access are provided to temporarily keep intermediate results.</p>
<p>在CPU内部，提供了少量（通常为8、16或32个）可快速访问的<strong>可寻址寄存器addressable registers</strong>，以<u>暂时保留中间结果。</u></p>
<p><img src="/images/NET/image-20210901074736076.png" /></p>
<ul>
<li>insert a <em>limited</em> number of <em>addressable</em> resigeters in CPU to store intermediate results</li>
</ul>
<p>As the number of registers is small, <u>the field to contain their address in the instructions</u> will be <strong>much shorter</strong> than those intended to contain memory addresses.</p>
<p>由于寄存器的数量很少，因此<u>在指令中包含其地址的字段</u>将比打算包含存储器地址的字段<strong>短得多</strong>。</p>
<p>To transfer data between memory and registers, <u>specific <strong>transfer instructions</strong> have to be <strong>added</strong> to the instruction set</u>.</p>
<p>为了在存储器和寄存器之间传输数据，必须<u>将特定的<strong>传输指令添加</strong>到指令集中</u>。</p>
<h5 id="data-handling-instructions">3.2.2.2 Data handling instructions</h5>
<p>The availability of registers in the central unit will optimize data processing instructions: <u>instead of using the memory to store the operands and the results,</u> registers can be used for this with a double benefit, firstly access to registers is significantly faster than a memory access and the register addresses are much shorter.</p>
<p>中央单元中寄存器的可用性将优化数据处理指令：<strong>无需使用内存</strong>来存储操作数和结果，</p>
<p>寄存器可用于此目的，具有双重好处：</p>
<ol type="1">
<li><p>Access to registers is significantly faster than a memory access<br />
</p>
<p>访问寄存器的<strong>速度</strong>明显<strong>快</strong>于内存访问</p></li>
<li><p>The register addresses are much shorter.</p>
<p>寄存器地址要短得多</p></li>
</ol>
<p><img src="/images/NET/image-20210901074838551.png" /></p>
<p>Data processing instructions with three addresses that refer all three to registers exist but sometimes only two explicit addresses are needed when the result will take the place of an operand.</p>
<p>存在具有三个地址的数据处理指令，这三个地址将全部三个都引用到寄存器，但是当结果代替操作数时，有时仅需要两个显式地址。</p>
<p>In some instruction sets, one of these two addresses is a memory address while the other is a register address. <u>This technique <strong>reduces</strong> the number of transfer instructions to be used in programs.</u></p>
<ul>
<li>memory address 存储器地址</li>
<li>register address 寄存器地址</li>
</ul>
<p>在某些指令集中，这两个地址之一是存储器地址，而另一个是寄存器地址。 该技术<u>减少了程序中要使用的传输指令transfer instructions的数量</u>。</p>
<h3 id="reduce-size-of-control-instructions-缩小控制指令">3.3 Reduce size of control instructions 缩小控制指令</h3>
<blockquote>
<p>前面介绍的都是在信息处理指令的容量缩小，下面介绍如何缩小控制指令</p>
</blockquote>
<p>Another way to reduce traffic between memory and CPU is to <u>adopt a specific organization for control instructions.</u></p>
<p>减少内存和CPU之间流量的另一种方法是采用<u>特定的控制指令组织</u>。</p>
<h4 id="condition-code-register">3.3.1 Condition code register</h4>
<p>As the operands to be compared are often the results of previous calculations a special register called "<strong>Register of conditions codes</strong>" is added to the arithmetic unit to record, at the end of each calculation, some outstanding properties are the result.</p>
<p>由于要比较的操作数通常是先前计算的结果，因此在运算单元中添加了一个称为“<strong>条件代码寄存器 Condition code register</strong>”的特殊寄存器，以便在每次计算结束时记录一些出色的属性。</p>
<p><img src="/images/NET/image-20210901074934554.png" /></p>
<p>The properties that are recorded in the register are, most often, a null result, a negative result, an arithmetic overflow or <u>deferral beyond the most significant bit</u> （to allow arithmetic operations on larger numbers than width of the arithmetic unit）.</p>
<p>寄存器中记录的属性通常是</p>
<ul>
<li>空结果null result</li>
<li>负结果negative result</li>
<li>算术溢出arithmetic overflow</li>
<li>超出最高有效位的递延deferral
<ul>
<li>以允许对大于算术单元宽度的数字进行算术运算。</li>
</ul></li>
</ul>
<p>Control instructions then choose the following instruction in function of the condition codes rather than in function of the comparison between two operands.</p>
<p>然后，控制指令<u>根据条件代码</u>而不是根据两个操作数之间的比较<u>来选择以下指令</u>。</p>
<p>In the control instruction it is therefore sufficient to provide a <strong><u>few bits to indicate the condition codes</u></strong> that must be taken into consideration which obviously takes much less space than the address of two operands.</p>
<p>因此，在控制指令中，提供一些位来<u><strong>指示必须考虑的条件码</strong>就足够</u>了，这显然比两个操作数的地址占用的空间少得多。</p>
<h3 id="augment-work-done-by-vector-instruction-增加指令工作量">3.4 Augment work done by vector instruction 增加指令工作量</h3>
<p>One last way to reduce traffic between memory and the CPU is to <u>increase the amount of work done by one instruction.</u></p>
<p>Vector instructions illustrate this principle.</p>
<p>减少内存和CPU之间流量的最后一种方法是<u>增加一条指令完成的工作量</u>。</p>
<p><strong>矢量指令vector instruction</strong>说明了这一原理。</p>
<h4 id="vector-instructions-矢量指令">3.4.1 Vector instructions 矢量指令</h4>
<p>In many programs one finds loops like the one shown in the picture.</p>
<p>许多程序中，人们会发现如下图所示的循环。</p>
<p><img src="/images/NET/image-20210901075010963.png" /></p>
<p>In fact, the <u><strong>same arithmetic operation</strong> on must be performed</u> on all the elements of a vector （e.g. represented by the array type）.</p>
<p>实际上，必须对向量的所有元素（例如，由数组类型表示）<u>执行<strong>相同</strong>的<strong>算术运算</strong></u>。</p>
<ul>
<li><p>With the kind of statements seen so far, it would be necessary for each element of the vector to fetch in memory the arithmetic instruction, the one that increments i, and finally, the control instruction that checks if the exit of the loop can be chosen.</p>
<p>就目前为止所看到的语句类型而言，有必要使向量的每个元素都在内存中提取算术指令，该算术指令将i递增，最后是检查是否可以选择循环退出的控制指令 。</p></li>
<li><p>In the case of long vectors, the same instructions are to be transferred many, many times.</p>
<p>对于长向量，相同的指令将被多次传输。</p></li>
</ul>
<p><img src="/images/NET/image-20210901075052196.png" /></p>
<p>Instead of transferring a large number of times the same instructions, there could be an <strong>extra field</strong> in some instructions that would <u>specify the number of <strong>times</strong> that the instruction must be <strong>repeated</strong> with consecutive vector elements</u>.</p>
<p>Such instructions are called "<strong>vector instructions</strong>" and contributed to the outstanding performance of the computers that are usually called "supercomputers", which are mainly used for numerical calculations. Such vector instructions can also come in handy in less prestigious applications.</p>
<p>在某些指令中可能会有一个<strong>额外</strong>的<strong>字段</strong>，而不是多次传输相同的指令，该字段将<u>指定必须使用连续的向量元素<strong>重复执行</strong>该指令的<strong>次数</strong></u> 。</p>
<blockquote>
<p>还记得for、while循环吗，在其中会设置一个counter，用于看是否到达了最终需要的结果，也可以在指令里设置一个counter</p>
</blockquote>
<p>这样的指令称为“<strong>矢量指令vector instructions</strong>”，有助于通常称为“超级计算机supercomputers”的计算机的出色性能，</p>
<p>They could, for example, be very valuable when it comes to fill in the pixels of a graphical display or to search for a word in a long text.</p>
<p>这些计算机主要用于数值计算。 这样的矢量指令在不太受欢迎的应用中也可以派上用场。</p>
<p>例如，在填充图形显示的像素或搜索长文本中的单词时，它们可能非常有价值。</p>
<h2 id="goal-2-support-for-high-level-language-hll">4. Goal 2: Support for High Level Language (HLL)</h2>
<blockquote>
<p>The different techniques to improve computer performance by reducing traffic between memory and CPU mentioned in this chapter apply to all programming styles, be it programming in elementary or in a high level language.</p>
<p>本章中提到的通过减少内存和CPU之间的通信量来提高计算机性能的不同技术适用于所有编程样式，无论是使用基本语言还是高级语言进行编程。</p>
</blockquote>
<p>To optimize the performance of programs written initially in a high level language, additional improvements can be made to the instruction set.</p>
<p>为了优化最初以高级语言编写的程序的性能，可以对指令集进行其他改进。</p>
<ul>
<li>Efficient subroutine call
<ul>
<li>Return address saving allowing re-entrance</li>
<li>Powerful para meter passing mechanisms</li>
</ul></li>
<li>Efficient access to data structures
<ul>
<li>Rich choice of addressing modes</li>
</ul></li>
<li>Efficient handling of block structured languages
<ul>
<li>Efficient access to local variables</li>
<li>Support for implementation of scope rules</li>
</ul></li>
</ul>
<p>This is more specifically to provide an efficient mechanism to call functions, to provide mapping techniques that allow access to complex data structures and to allow an efficient management of the accessibility rules dictated by block structured languages.</p>
<p>更具体地说，这提供了一种调用函数的有效机制，提供了允许访问复杂数据结构的映射技术，并允许对由块结构语言规定的可访问性规则进行有效管理。</p>
<h3 id="calling-functions-调用函数">4.0 Calling functions 调用函数</h3>
<p>Calling functions is implemented at the machine level by control instructions that can jump to a specific piece of the program (subroutine) to run this subroutine and to return to the original program at the instruction following the one that caused the jump to the subroutine.</p>
<p>调用功能是通过控制指令在机器级别实现的，控制指令可以跳转到程序的特定部分（子例程）以运行此子例程，并根据导致跳转到该子例程的指令之后的指令返回到原始程序。</p>
<p>The manner in which the control unit "remembers" the address of the instruction that will run after the end of the subroutine (the "<strong>return address</strong>") can have a great influence on the efficiency of execution of programs written in high level language.</p>
<p>控制单元“记住”将在子例程结束之后运行的指令的地址（“<strong>返回地址return address</strong>”）的方式可能会对以高级语言编写的程序的<u>执行效率产生重大影响</u>。</p>
<h3 id="efficient-subroutine-call">4.1 Efficient subroutine call</h3>
<h4 id="return-address-saving-allowing-reentrance">4.1.1 Return address saving allowing reentrance</h4>
<p>The technique used in virtually all modern computers is to use part of the data memory to retain the return addresses.</p>
<p>实际上，所有现代计算机中使用的技术都是使用部分数据存储器来保留返回地址。</p>
<p><img src="/images/NET/image-20210901075148675.png" /></p>
<ul>
<li>return address on stack in data memory</li>
</ul>
<p>This part of the memory is organized in a "first in, last out" structure called "stack".</p>
<p>存储器的这一部分以称为“<strong>堆栈stack</strong>”的“<u>先进先出first in, last out</u>”结构进行组织。</p>
<ul>
<li><p>When executing the jump instruction to the subroutine, the address of the next instruction is pushed on the stack and a jump to the first instruction of the subroutine is performed.</p>
<p>当执行跳转指令到子程序时，下一条指令的地址被压入堆栈，并跳转到子程序的第一条指令。</p></li>
<li><p>At the end of the subroutine, there is a specific instruction to <u>return to the calling program.</u></p>
<p>This statement is actually a jump instruction whose destination is taken from the top of the stack.</p>
<p>在子例程subroutine的末尾，有一条特定的指令<u>返回到调用程序</u>。</p>
<p>该语句实际上是一条跳转指令jump instruction，其目的地是从栈顶获取的。</p></li>
</ul>
<h5 id="recursion-递归">4.1.1.1 Recursion 递归</h5>
<p><img src="/images/NET/image-20210901075238019.png" /></p>
<p>Thanks to the use of a stack for storing the return addresses, recursive subroutine calls become possible. For each separate call, <u>a return address is stored on the stack.</u></p>
<p>由于使用了堆栈来存储返回地址，因此可以进行递归子程序调用。 <u>对于每个单独的调用，返回地址都存储在堆栈中</u>。</p>
<h4 id="powerful-para-meter-passing-mechanisms">4.1.2 Powerful para meter passing mechanisms</h4>
<p>Parameters are a major asset of functions in high-level languages. It is therefore essential to provide mechanisms that ensure the efficiency of parameter passing.</p>
<p>参数是高级语言中函数的主要资产。 因此，必须提供确保参数传递效率的机制。</p>
<h5 id="function-parameters">4.1.2.0 Function Parameters</h5>
<p>Parameters allow you to use the same function with different variables.</p>
<p>参数允许您将相同的函数与不同的变量一起使用。</p>
<blockquote>
<p>A little analogy will clarify this concept, imagine a very organized person writing instruction sheets for all activities of daily living. Imagine that this person writes an instruction sheet to invite a friend to the restaurant. At the time of writing the sheet the identity of the friend is not yet known and will appear under the heading "my friend."</p>
<p>This substitute for the actual name of the friend is called "<strong>formal parameter"</strong>.</p>
<p>稍作类推就能阐明这个概念，想象一个非常有条理的人为日常生活的所有活动编写说明表。 想象一下，这个人写了一个说明表，邀请朋友去餐馆。 在撰写表格时，朋友的身份尚不清楚，并将显示在“我的朋友”标题下。</p>
<p>代替朋友的实际姓名的方式称为“<strong>形式参数 formal parameter</strong>”。</p>
<p>When the sheet is used, the identity of the friend is known, and we replace the formal parameter by the actual name of the friend. This real name will be called “<strong>actual parameter</strong>"</p>
<p>使用表格时，朋友的身份是已知的，我们用朋友的实际姓名替换形式参数。 此真实名称将称为“<strong>实际参数 actual parameter</strong>”。</p>
</blockquote>
<p><img src="/images/NET/image-20210901075706554.png" /></p>
<p>In the example shown on the screen, the function DoCCC has a formal parameter <code>xyz</code> which is substituted in the first use of DoCCC by the actual parameter <code>abc</code> and in the second, by the actual parameter <code>uvw</code>.</p>
<p>在屏幕上显示的示例中，函数DoCCC具有形式参数<code>xyz</code>，该形式参数在DoCCC的第一次使用中由实际参数<code>abc</code>替换，在第二个用法中由实际参数<code>uvw</code>替换。</p>
<h5 id="parameters-passing">4.1.2.1 Parameters passing</h5>
<p>There are several different methods to associate current and formal parameters.</p>
<p>有几种不同的方法可以关联当前参数和形式参数。</p>
<ul>
<li>By value</li>
<li>By reference</li>
</ul>
<h6 id="parameters-passing-by-value-值传递">4.1.2.1.1 Parameters passing by value 值传递</h6>
<blockquote>
<p>值传递：对原来的值取copy，非常好理解</p>
</blockquote>
<p>With the first method, called "passing by value“, the value of the actual parameter is copied on the stack before the call.</p>
<p>In this way, the function can possibly change the value of the formal parameter without this affecting the actual parameter value, since the formal parameter is a copy of the actual one.</p>
<p>使用第一种方法，即“按值传递”，在调用之前将实际参数的值复制到堆栈上，这样，函数就可以更改形式参数的值，而不会影响实际参数的值，因为形式参数是实际参数的副本。</p>
<p><img src="/images/NET/image-20210901075735127.png" /></p>
<p>If the parameter is a <strong>structured type</strong>, possibly large, one must be aware that before any call, the parameter values must be copied, which can <u>require a lot of space and time.</u></p>
<p>The fact that the formal parameter is a copy of the actual parameter is a protection of the calling program against the actions of the function.</p>
<p>如果参数是<strong>结构化类型structured type</strong>（可能很大），则必须意识到在进行任何调用之前，必须先复制参数值，这<u>可能需要大量空间和时间</u> 。</p>
<p>形式参数是实际参数的副本这一事实可以保护调用程序免受该函数的作用，</p>
<p>One could, for example, imagine a function that calculates the sine of an angle beginning by bringing the angle in the first quadrant, but it is unlikely that the author of a program appreciates when that angle is amended by the sine function. Since only the value of the actual parameter is used, it can be any expression whose value belongs to the type of the formal parameter.</p>
<p>例如，我们可以想象一个函数，该函数通过将角度带入第一象限开始计算角度的正弦，但是程序的作者不太可能会欣赏通过正弦函数修正该角度的情况。 由于只使用了实参的值，所以它可以是任何值属于形参类型的表达式。</p>
<h6 id="parameters-passing-by-reference-引用传递">4.1.2.1.2 Parameters passing by reference 引用传递</h6>
<blockquote>
<p>Indirect addressing</p>
<p>引用传递：calling program提供这个值的地址，在地址上操作。</p>
</blockquote>
<p>The other popular method for passing parameters is called "by reference".</p>
<p>传递参数的另一种流行方法称为“通过引用”。 在这种情况下，调用程序不提供实际参数的值，而是提供其地址。</p>
<p><img src="/images/NET/image-20210901075803286.png" /></p>
<p>In this case, the calling program does not provide the value of the actual parameter but its address. In this way, using <strong>indirect addressing</strong>, the called function can directly access the actual parameter and modify its value.</p>
<p>This is the mode normally used with structured types of parameters because it avoids the waste of time and space associated with the copying of the contents of the actual parameter.</p>
<p>这样，通过使用<strong>间接寻址</strong>，被调用函数可以直接访问实际参数并修改其值。</p>
<p>这是通常用于结构化类型的参数的模式，因为它避免了与复制实际参数的内容相关的时间和空间的浪费。</p>
<p>Whatever the size of the actual parameter, it will <u>only require the size of an address on the stack</u>.</p>
<p>无论实际参数的大小如何，它<u>仅需要堆栈上地址的大小</u>。</p>
<h5 id="values-returned-by-function">4.1.2.2 Values returned by function</h5>
<blockquote>
<p>直接取出stack最上面的值。</p>
</blockquote>
<p>Most functions return a value to the program that called them. This is also done through the stack.</p>
<p>大多数函数向调用它们的程序返回一个值。 这也是通过堆栈完成的。</p>
<p><img src="/images/NET/image-20210901075900508.png" /></p>
<p>The calling program before placing parameters on the stack, reserves a place for the value that the function will return.</p>
<p>Putting the value returned below the parameters allows, after the execution of the function, to remove from the stack all that concerned the function call, except the returned value.</p>
<p>在将参数放置在堆栈上之前，调用程序将为函数将返回的值保留一个位置。</p>
<p>将返回的值放在参数下方允许执行函数后，从堆栈中删除所有与函数调用有关的内容，但返回的值除外。</p>
<h3 id="efficient-access-to-data-structures">4.2 Efficient access to data structures</h3>
<p>A major advantage of high-level languages is the ability to organize data into complex structures such as tables, structures, linear lists, binary trees and even quite arbitrary graphs.</p>
<p>高级语言的主要优点是能够将数据组织成复杂的结构，例如表，结构，线性列表，二叉树甚至是任意图。</p>
<p>For quick and comfortable access to such data structures, it is essential that the computer has various <strong>addressing modes,</strong> well adapted to the data structures.</p>
<p>为了快速，舒适地访问此类数据结构，计算机必须具有各种<strong>寻址模式</strong>，并且非常适合该数据结构，这一点至关重要。</p>
<h4 id="addressing-modes-寻址模式">4.3.1 Addressing modes 寻址模式</h4>
<ul>
<li>Direct addressing 直接寻址</li>
<li>Indirect addressing 间接寻址</li>
<li>Relative addressing 相对寻址</li>
</ul>
<h5 id="direct-addressing-直接寻址">4.3.1.1 Direct addressing 直接寻址</h5>
<p>最简单的寻址模式是<strong>直接寻址direct addressing</strong>。</p>
<blockquote>
<p>直接定位memory里的地址</p>
<p>此模式在本课程的所有先前说明中已隐式使用。</p>
</blockquote>
<p><img src="/images/NET/image-20210901075327964.png" /></p>
<p>It consists simply <u>in directly mentioning the desired address in the appropriate fields of the instructions.</u></p>
<p>This mode is frequently used for program memory addresses that are found in the jump instructions, as well as in data processing instructions for referencing simple, unstructured variables.</p>
<p>它仅包括在指令的相应字段中<u>直接提及所需的地址</u>。</p>
<p>此模式通常用于跳转指令以及用于引用简单非结构化变量的数据处理指令中找到的程序存储器地址。</p>
<h5 id="indirect-addressing-间接寻址">4.3.1.2 Indirect addressing 间接寻址</h5>
<blockquote>
<p>先定位地址的地址，再转接到地址。更常见的是在register里得到地址的地址，然后在memory里定位地址。</p>
</blockquote>
<p><strong>Indirect addressing</strong> consists in mentioning in the instructions, instead of the address of the operands, t<u>he address where the address of the operands can be found</u>.</p>
<p><strong>间接寻址</strong>包括在指令中提及，而不是操作数的地址，而是可以<u>找到操作数地址的地址</u>。</p>
<blockquote>
<p>This addressing mode corresponds in many high-level languages with the use of pointers.</p>
<p>在许多高级语言中，此寻址模式都使用指针。</p>
<p>A pointer is a variable that contains the address of another variable. Instead of directly referencing the latter, one reference in the instruction the pointer through which one can access the variables themselves.</p>
<p>指针是一个变量，其中包含另一个变量的地址。 而不是直接引用后者，而是在指令中引用指针，指针可以通过指针本身访问变量。</p>
</blockquote>
<h5 id="through-memory">4.3.1.2.1 Through memory</h5>
<p><img src="/images/NET/image-20210901075405214.png" /></p>
<p>This method allows to build structured variables and to pass to functions the address of an actual parameter rather than a copy of the parameter  （passing parameters by <strong>reference</strong> instead of by value）.</p>
<p>此方法允许构建结构化变量structured variables并将实际参数的地址而不是参数的副本传递给函数（<u>通过<strong>引用</strong></u>而不是通过值<u>传递参数</u>）。</p>
<p>Such passing by reference allows the function to <u>change the value of its actual parameters</u>, while passing by value limits the influence of the function to the <strong>formal parameters</strong> that are only copies of the actual parameters.</p>
<p>这种通过引用的传递<u>允许函数更改其实际参数的值</u>，而通过值传递将函数的影响限制为<strong>形式参数formal parameters</strong>，形式参数仅是实际参数的副本。</p>
<h6 id="through-registers">4.3.1.2.2 Through registers</h6>
<p>Sometimes indirect addressing is done through a register rather than through the memory.</p>
<p>The address contained in the instruction is that of a register which contains the address in memory of the operand desired.</p>
<p>有时间接寻址是通过寄存器而不是通过存储器完成的。</p>
<p>指令中包含的地址是<strong>寄存器的地址</strong>，该寄存器包含所需操作数在内存中的地址。</p>
<p><img src="/images/NET/image-20210901075445978.png" /></p>
<p>This technique is, for example, used to <strong>manage a stack</strong> such as the one mentioned in the study of subroutine call instructions : A special register, called "<strong>stack pointer</strong>" contains <u>the address of the <strong>first free place</strong> on the stack.</u></p>
<p>The subroutine <strong>call instruction</strong> writes the return address to the address contained in the stack pointer and increments the contents thereof.</p>
<p>The subroutine <strong>return instruction</strong> first decrements the content of the stack pointer and then performs a jump to the address in memory at the location indicated by the contents of the stack pointer.</p>
<p>例如，此技术用于<strong>管理堆</strong>栈，例如在子例程调用指令的研究中提到的堆栈：称为“<strong>堆栈指针stack pointe</strong>r”的特殊寄存器<u>包含堆栈上第一个空闲位置的地址</u>。</p>
<p>子例程调用call指令将返回地址写入堆栈指针中包含的地址，并递增其内容。</p>
<p>子例程返回return指令首先递减堆栈指针的内容，然后在堆栈指针的内容所指示的位置执行到内存中地址的跳转。</p>
<h5 id="relative-addressing-相对寻址">4.3.1.3 Relative addressing 相对寻址</h5>
<p>There is talk of <strong>relative addressing</strong> when the <u>address contained in the instruction is added to the contents of a register before being used to reference a word in memory.</u></p>
<p>Relative addressing is primarily used to access elements of an array or structure.</p>
<p><strong>相对寻址relative addressing</strong>是指<u>将指令中包含的地址在引用内存中的字之前添加到寄存器的内容中</u>。</p>
<blockquote>
<p>想象这是一个数组，有index和base，其实先定位的是base基准数，然后index是在地址中的offset（偏移量），这样是不是就能理解数组是从0开始的了。</p>
</blockquote>
<p>相对寻址主要用于访问<strong>数组array</strong>或<strong>结构structure</strong>的元素。</p>
<p><img src="/images/NET/image-20210901075514174.png" /></p>
<ul>
<li><p>For tables, the address of the first array element （corresponding to the index 0） is placed in the address field of the instruction while the value of the index is placed in a register.</p>
<p>对于表，第一个数组元素的地址（对应于索引0）放置在指令的地址字段中，而索引的值放置在寄存器中。</p></li>
<li><p>For structures, on the contrary, it is often preferred to place the address of the beginning of the structure in a register while the address of the specific field is placed in the instruction.</p>
<p>相反，对于结构，通常最好将结构开始的地址放在寄存器中，而将特定字段的地址放在指令中。</p></li>
</ul>
<p>This addressing mode is also used in the jump instruction using the <u><strong>program counter</strong> as reference register.</u></p>
<p>This technique then allows to jump forward or backward relative to the location of the control instruction. As in most structured programs jumping from one end of the program to another is avoided, one can use mostly short addresses in the control instructions.</p>
<p>在使用程序计数器作为参考寄存器的跳转指令中，也使用该寻址模式。</p>
<p>然后，该技术允许相对于控制指令的位置向前或向后跳转。由于在大多数结构化程序中都避免了从程序一端跳到另一端，因此在控制指令中可以使用大多数短地址。</p>
<h3 id="efficient-handling-of-block-structured-languages">4.3 Efficient handling of block structured languages</h3>
<p>Most high-level languages are block structured and each block may possess local variables.</p>
<p>This organization helps <u>limiting the scope of each variable declaration in the area</u> in which the variable is actually used and thus <u>avoid errors that come from the indiscriminate use of homonymous variables</u>.</p>
<p>大多数高级语言都是块结构的，每个块可能具有局部变量。</p>
<p>该组织有助于将<u>每个变量声明的范围限制在实际使用该变量的区域</u>，从而<u>避免因滥用indiscriminate use同名变量homonymous variables而引起的错误</u>。</p>
<p>As each block can itself contain other blocks, a nontrivial management of <u><strong>the scope of variable declarations</strong></u> is needed.</p>
<p>Part of this management can be done by the compiler in translating the high-level language into machine language, but there is a need <u>for <strong>dynamic allocation of memory</strong> for the different variables during program execution.</u></p>
<p>由于每个块本身可以包含其他块，因此需要<u>对变量声明的范围进行非平凡的管理</u>。</p>
<p>这种管理的一部分可以由编译器将高级语言翻译为机器语言来完成，但是需要在程序执行期间<u>为不同变量<strong>动态分配内存</strong></u>。</p>
<p>Instructions that optimize this management contribute to an efficient execution of programs written in high level languages.</p>
<p>优化此管理的指令有助于以高级语言编写的程序的有效执行。</p>
<h4 id="block-structured-language">4.3.0 Block structured language</h4>
<blockquote>
<p>这些block通常都有层次，实际上在memory中是运用static link和dynamic link连接而成的。</p>
</blockquote>
<p>In most high-level languages, a program is a set of nested blocks. C, C ++ and Java blocks are delimited by braces.</p>
<p>在大多数高级语言中，程序是一组嵌套块。 C，C ++和Java块用花括号分隔。</p>
<p>Blocks can be considered as surrounded by semi-transparent fences: from anywhere in a block everything declared in that block can be <u>accessed except what is <strong>hidden in an inner block</strong>.</u></p>
<p>可以将块视为被半透明的栅栏包围：可以从块中的任何位置访问该块中声明的所有内容，<u>但隐藏在内部块中的内容除外</u>。</p>
<p><img src="/images/NET/image-20210901075539977.png" /></p>
<ul>
<li>A program is a set of nested blocks</li>
</ul>
<p>In the above example, variables declared in the blue block can be accessed from everywhere, while variables declared in the red block can only be accessed from inside that block.</p>
<p>在上面的示例中，可以从任何地方访问在蓝色块中声明的变量，而只能从该块内部访问在红色块中声明的变量。</p>
<p><img src="/images/NET/image-20210901075624259.png" /></p>
<h4 id="dynamic-links---local-variables">4.3.1 Dynamic Links - local variables</h4>
<p>Whenever a block is activated by a function call, space for its local variables is reserved on the stack in data memory which is also used for keeping track of the return addresses.</p>
<p>每当通过功能调用激活一个块时，用于其局部变量的空间就会在堆栈中的数据存储器中保留，该存储器也用于跟踪返回地址。</p>
<p>When a block is no longer in use （because of a return statement） the memory space reserved for the local variables is made free.</p>
<p>当不再使用块时（由于有return语句），为局部变量保留的存储空间将被释放。</p>
<p>The dynamic management of the stack part of the data memory is done by means of pointers called "<strong>dynamic links</strong>" .</p>
<p>数据存储器堆栈部分的动态管理是通过称为“<strong>动态链接 dynamic links</strong>”的指针完成的</p>
<h4 id="static-links---global-variables">4.3.2 Static Links - global variables</h4>
<p>In addition to local variables, functions also need access to global variables.</p>
<p>除了局部变量，函数还需要访问<strong>全局变量</strong>。</p>
<p>For this, we will provide above the dynamic links space for an other pointer, the static link that contains the start address of the block in which global variables are located.</p>
<p>为此，我们将在动态链接空间上方为另一个指针提供静态链接，该静态链接包含全局变量所在的块的起始地址。</p>
<blockquote>
<p>Since all functions are defined at the same level in C and derived languages, the management of static links is trivial.</p>
<p>由于所有功能都用C和派生语言在同一级别定义，因此静态链接的管理很简单。</p>
<p>In languages that allow the definition of functions within other functions such management is substantially more complex.</p>
<p>在允许在其他功能中定义功能的语言中，这种管理要复杂得多。</p>
</blockquote>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Chaoqun Yin</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://yintelligence.tech/2021/07/21/2021-07-21-CPU/">https://yintelligence.tech/2021/07/21/2021-07-21-CPU/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint polocy. If reproduced, please indicate source
                    <a href="/about" target="_blank">Chaoqun Yin</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Computer-Systems/">
                                    <span class="chip bg-color">Computer Systems</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2021/07/22/2021-07-22-Xen/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="XEN">
                        
                        <span class="card-title">XEN</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-07-22
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Computer-Systems/" class="post-category">
                                    Computer Systems
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Operating-Systems-and-Security/">
                        <span class="chip bg-color">Operating Systems and Security</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/07/20/2021-07-20-SP0-A-Stack-Processor/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/13.jpg" class="responsive-img" alt="SP0- A Stack Processor">
                        
                        <span class="card-title">SP0- A Stack Processor</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            第四章，介绍一种LIFO栈数据存储器
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-07-20
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Computer-Systems/" class="post-category">
                                    Computer Systems
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Computer-Systems/">
                        <span class="chip bg-color">Computer Systems</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + 'From: Chaoqun Yin<br />'
            + 'Author: Chaoqun Yin<br />'
            + 'Link: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">Chaoqun Yin</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2021";
                    var startMonth = "1";
                    var startDate = "28";
                    var startHour = "2";
                    var startMinute = "1";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/yintelligence" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:Yintelligence@outlook.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
